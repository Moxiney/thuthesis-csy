% !TeX root = ../thuthesis-caishiyu.tex

\chapter{数据恢复机制设计}
\label{chap:recovery}

\subsection{本章概述}

数据库存储了大量的数据库，同时为了保证重启之后数据的完整性，因此数据库在恢复要遵循以下两个原则：

1. 提交事务所造成的所有的变化必须持久化。
2. 任何中止的事务和任何在系统宕机时处于运行时的事务的所造成的变化必须在重启之后是透明的。

这两条原则脱胎于数据库的持久化要求和原子化要求。持久化要求提交事务的影响能够持久化。而原子性要求要保证中止事务和因为宕机结束的事务的所造成的影响被消除。

传统的数据库由于内存是非易失性的，因此普遍采用的是 Write-ahead-log（WAL），也就是当事务的提交的时候行为主要分为三步：

1. 收集所有操作所对应的日志，日志的每一个条目对应着事务的某一个操作，比如插入，更新等，并且会记录操作前的前象。之后将日志持久化到持久化介质上。
2. 将事务状态记为提交。
3. 将对数据的修改持久化到持久化介质上。

采用这种方式，当数据库重启之后，由于日志总是提前持久化到持久化介质上，因此数据库管理系统可以通过日志保证两个原则。首先，对于第一个原则所涉及的提交的事务而言，有两种情况，一是数据的修改已经持久化，二是数据的修改尚未持久化但是日志已经持久化了。对于前者，数据库管理系统不需要做什么，而对于后者，根据日志上的记录，数据库可以重新实现该事务所造成的影响，通常称之为 redo。其次，对于第二个原则所涉及的中止或者因为宕机停止的事务而言，根据日志，数据库可以重现该事务所造成的影响，也就是 redo，之后根据日志中所记录的数据的前象，再消除该事务的影响，通常称之为 undo。

WAL 在正确性访问是毋庸置疑的，但是其有两个重大的弊端：

1. 附加的开销较大。当事务运行时，每一次操作都要生成与之对应的日志条目，其中需要将之前的数据复制过去，通常而言，此类复制的操作开销较大。
2. 事务延迟大。每当事务提交时，都需要将日志和数据的先后持久化到持久化介质上。但是由于持久化介质到内存中的延迟大，且通常是块寻址的。为了降低 I/O 所带来的开销，大部分数据库选择将一个组的事务一起提交，称之为 group commit，然后一次性的将这些事务的日志和数据库持久化。但是所带来的弊端就是，事务启动和提交之间的时间差扩大，也就是延迟大。
3. 存储空间利用率低。在运行时，为了保证性能，内存中会保留一部分热数据。在持久化介质上，日志也记录了一部分数据用于恢复。因此对于数据文件里的某一个 tuple 而言，其有可能在内存和日志分别存放两个副本，空间利用率低。

虽然 WAL 是正确的，但是会影响性能。基于 NVM 的低延迟和字节寻址的优势，我们提出不依赖日志的运行时策略，目的在于提高系统的吞吐率，降低事务的延迟，同时最大化地利用存储空间。基于此运行时策略，我们提出对应的不依赖日志的恢复策略，使系统能够在重启之后根据数据，能够正确建立目录，回收多余的存储空间，并且能尽快提高服务。

在接下来的子章节中，我们将按恢复策略的顺序详细说明。我们将着重于数据持久化部分，而在恢复策略中，我们会详细阐述数据的组织方式，重启之后的恢复流程，以及恢复策略的正确性。

\section{数据恢复流程}

我们所涉及的恢复策略有以下几个目标。首先是 NVM 空间的管理系统的重建。一些 NVM 工作使用的是类似于 PMDK 的 NVM 分配器协助管理，其好处在于使用者不需要手动维护分配信息，但是其代价在于 PMDK 是通过日志保证分配信息的持久化的，因此延迟较大，通常有（我记得某篇论文里有PMDK 的分配延迟）。因此我们采用的是手动管理 NVM 空间，因此在重启之后，需要根据持久化信息重新得到空间的分配信息。其次是数据库管理系统的重建，根据 NVM 空间管理系统的分配信息，我们可以找到数据库管理系统的元数据。根据这些信息，系统需要恢复事务，表格，索引等等信息。最后则是数据完整性，在我们上文提到过，数据的完整性主要通过遵循两个原则来保证。在重启之后，数据库管理系统会得到所有的正确的表格信息，在此基础上，系统需要保证提交的事务的影响以及消除中止和因宕机停止的事务的影响，回收空余的空间，并且尽可能快地提供后续的正常的服务。

\subsection{NVM 分配器的恢复流程}

\subsection{数据库元数据的恢复流程}

\subsection{记录数据的恢复流程}

\section{数据恢复的正确性}


\section{系统工程实现}

\section{本章小结}